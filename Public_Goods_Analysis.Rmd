---
title: "Public_Goods_Analysis"
author: "Simon van Baal"
date: "19/11/2020"
output: html_document
---

```{r libraries, warning=F}
library(tidyverse)
library(afex)
library(ggplot2)
library(ggpubr)
library(emmeans)
library(broom)


```

```{r load data, warning=F}
publicGoodsData <- read_csv('CleanedPublicGoods.csv') %>%
  filter(subsession.round_number <= 20)

```

```{r Figures for visualisation}
ggplot(publicGoodsData, aes(x = player.contribution, 
                            fill = group.condition)) +
  geom_density(alpha = .4) +
  labs(x = 'Contribution', y = 'Density')

ggplot(publicGoodsData %>% filter(player.my_endowment != 160 & player.my_endowment != 240) %>% mutate(Endowment = factor(player.my_endowment)),
       aes(x = player.contribution,
           fill = Endowment)) +
  geom_density(alpha = .4) +
  labs(x = 'Contribution', y = 'Density')



ggplot(publicGoodsData %>%
         group_by(subsession.round_number) %>%
         summarise(lockdown = mean(group.lockdown)),
       aes(x = subsession.round_number, y = lockdown)) +
  geom_point()

ggplot(publicGoodsData %>% 
         filter(group.total_infections < 6) %>%
         mutate(Infections = factor(group.total_infections),
                Contribution = player.contribution),
       aes(x = Infections,
           y = Contribution,
           fill = Infections)) +
  geom_violin() +
  scale_fill_viridis_d(end = .9) +
  theme_light()

#============================== C-game: Self-isolation by cases in group

ggplot(publicGoodsData %>%
         filter(group.total_infections < 6, player.second_player_contribution_0 != 5) %>%
         mutate(`Cases in group` = as.numeric(group.total_infections)) %>%
         group_by(`Cases in group`) %>%
         summarise(`Self-isolation` = mean(player.contribution, na.rm = T),
                   lowerCi = `Self-isolation` - 1.96*sd(player.contribution, na.rm = T)/sqrt(n()),
                   upperCi = `Self-isolation` + 1.96*sd(player.contribution, na.rm = T)/sqrt(n())),
       aes(x = `Cases in group`, y = `Self-isolation`)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = lowerCi, ymax = upperCi), width = .1) +
  labs(title = 'Incentivised self-isolation by number of infections',
       x = 'Number of infections in group',
       y = 'Incentivised self-isolation') +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), 
                     labels = c('None (0)', 
                                'Slight (1)' , 
                                'Moderate (2)', 
                                'Stringent (3)', 
                                'Complete (4)'), 
                     minor_breaks = c(.5, 1.5, 2.5, 3.5),
                     limits = c(0,4)) +
  theme_light()

ggplot(publicGoodsData %>%
         filter(player.second_player_contribution_0 != 5) %>% 
         group_by(session.code, subsession.round_number) %>%
         summarise(`Self-isolation` = mean(player.contribution)) %>%
         ungroup() %>%
         arrange(subsession.round_number) %>% 
         mutate(`Average self-isolation in previous round` = ),
       aes(x = `Self-isolation`,
           y = `Average self-isolation in previous round`)) +
  geom_point()

#============================= round number stuff
ggplot(publicGoodsData %>% 
         group_by(subsession.round_number) %>%
         summarise(`Self-isolation` = mean(player.contribution, na.rm = T)) %>%
         rename(`Round Number` = subsession.round_number), 
       aes(x = `Round Number`,
           y = `Self-isolation`)) +
  geom_point() +
  geom_smooth() +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), 
                     labels = c('None (0)', 
                                'Slight (1)' , 
                                'Moderate (2)', 
                                'Stringent (3)', 
                                'Complete (4)'), 
                     minor_breaks = c(.5, 1.5, 2.5, 3.5),
                     limits = c(0,4)) +
  theme_light() +
  theme(axis.text = element_text(size = 7))

# ggplot(publicGoodsData %>% 
#          group_by(subsession.round_number, group.condition) %>%
#          summarise(player.contribution = mean(player.contribution, na.rm = T)), 
#        aes(x = subsession.round_number,
#            y = player.contribution,
#            colour = group.condition)) +
#   geom_point() +
#   geom_smooth() +
#   lims(y = c(0,4)) +
#   theme_light()



```


```{r P Game figures}

pGameOthers #  <-
  ggplot(publicGoodsData %>% 
         filter(player.second_player_contribution_0 != 5) %>% 
         summarise(SecondPlayer0 = mean(player.second_player_contribution_0, na.rm = T),
                              lowerciSecondPlayer0 = SecondPlayer0 - 1.96*(sd(player.second_player_contribution_0, na.rm = T)/sqrt(n())),
                              upperciSecondPlayer0 = SecondPlayer0 + 1.96*(sd(player.second_player_contribution_0, na.rm = T)/sqrt(n())),
                              SecondPlayer1 = mean(player.second_player_contribution_1, na.rm = T),
                              lowerciSecondPlayer1 = SecondPlayer1 - 1.96*(sd(player.second_player_contribution_1, na.rm = T)/sqrt(n())),
                              upperciSecondPlayer1 = SecondPlayer1 + 1.96*(sd(player.second_player_contribution_1, na.rm = T)/sqrt(n())),
                              SecondPlayer2 = mean(player.second_player_contribution_2, na.rm = T),
                              lowerciSecondPlayer2 = SecondPlayer2 - 1.96*(sd(player.second_player_contribution_2, na.rm = T)/sqrt(n())),
                              upperciSecondPlayer2 = SecondPlayer2 + 1.96*(sd(player.second_player_contribution_2, na.rm = T)/sqrt(n())),
                              SecondPlayer3 = mean(player.second_player_contribution_3, na.rm = T),
                              lowerciSecondPlayer3 = SecondPlayer3 - 1.96*(sd(player.second_player_contribution_3, na.rm = T)/sqrt(n())),
                              upperciSecondPlayer3 = SecondPlayer3 + 1.96*(sd(player.second_player_contribution_3, na.rm = T)/sqrt(n())),
                              SecondPlayer4 = mean(player.second_player_contribution_4, na.rm = T),
                              lowerciSecondPlayer4 = SecondPlayer4 - 1.96*(sd(player.second_player_contribution_4, na.rm = T)/sqrt(n())),
                              upperciSecondPlayer4 = SecondPlayer4 + 1.96*(sd(player.second_player_contribution_4, na.rm = T)/sqrt(n()))) %>%
  pivot_longer(cols = everything(), names_to = c('Conditional'), values_to = c('Values')) %>%
  mutate(number = rep(c(0,1,2,3,4), each = 3),
         Conditional = rep(c("Contribution", "lowerCi", "upperCi"), times = 5)) %>%
  pivot_wider(id = 'number', names_from = 'Conditional', values_from = 'Values') %>%
  rename(`Others' self-isolation` = number,
         `Self-isolation` = Contribution),
  aes(x = `Others' self-isolation`, 
      y = `Self-isolation`)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin=lowerCi, ymax=upperCi), colour="black", width=.1) +
  scale_x_continuous(breaks = c(0, 1, 2, 3, 4), labels = c('None (0)', 'Slight (1)', 'Moderate (2)', 'Stringent (3)', 'Complete (4)')) +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), 
                     labels = c('None (0)', 
                                'Slight (1)' , 
                                'Moderate (2)', 
                                'Stringent (3)', 
                                'Complete (4)'), 
                     minor_breaks = c(.5, 1.5, 2.5, 3.5),
                     limits = c(0,4)) +
  labs(title = 'Hypothetical self-isolation conditional on average contribution in group',
       y = 'Hypothetical self-isolation',
       x = 'Assumed self-isolation of others') +
  theme_light() +
  theme(axis.text = element_text(size = 7))

pGameInfections <- 
  ggplot(publicGoodsData %>%
         filter(player.second_player_contribution_0 != 5) %>%
         group_by(group.total_infections) %>%
         summarise(`Self-isolation` = mean(c(player.second_player_contribution_0,
                                         player.second_player_contribution_1,
                                         player.second_player_contribution_2,
                                         player.second_player_contribution_3,
                                         player.second_player_contribution_4)),
                   lowerCi = `Self-isolation` -
                     1.96*sd(c(player.second_player_contribution_0,
                                         player.second_player_contribution_1,
                                         player.second_player_contribution_2,
                                         player.second_player_contribution_3,
                                         player.second_player_contribution_4))/sqrt(n()*5), #multiply n by five as averaging over 5 cols
                   upperCi = `Self-isolation` +
                     1.96*sd(c(player.second_player_contribution_0,
                                         player.second_player_contribution_1,
                                         player.second_player_contribution_2,
                                         player.second_player_contribution_3,
                                         player.second_player_contribution_4))/sqrt(n()*5)) %>%
         rename(`Number of cases in group` = group.total_infections),
       aes(x = `Number of cases in group`, y = `Self-isolation`)) +
  geom_point() +
  geom_line() +
  #geom_ribbon(aes(ymin = lowerCi, ymax = upperCi), alpha = .1) +
  geom_errorbar(aes(ymin=lowerCi, ymax=upperCi), colour="black", width=.1) +
  labs(title = 'Hypothetical self-isolation by number of cases in group', y = ' ') +
  theme_light() +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), 
                     labels = NULL, 
                     minor_breaks = c(.5, 1.5, 2.5, 3.5),
                     limits = c(0,4)) +
  theme(axis.text = element_text(size = 7))

ggarrange(pGameOthers, pGameInfections) +
  ggsave("pGamePlots.png", width = 12, height = 5)




```


```{r second player comparison}

a <- ggplot(publicGoodsData %>% filter(!is.na(player.second_player_contribution_0)), 
       (aes(x = factor(player.second_player_contribution_0), y = player.contribution, col = group.total_infections))) +
  geom_jitter(height = .3, width = .3) +
  scale_colour_viridis_c(begin = 0, end = .85) +
  labs(x = 'Response if Second Player Contribution = No Self-Isolation', 
       y = 'Actual Response',
       col = 'Number of infections') +
  theme_light()
b <- ggplot(publicGoodsData %>% filter(!is.na(player.second_player_contribution_1)), 
       (aes(x = factor(player.second_player_contribution_1), y = player.contribution, col = group.total_infections))) +
  geom_jitter(height = .3, width = .3) +
  scale_colour_viridis_c(begin = 0, end = .85) +
  labs(x = 'Response if Second Player Contribution = Slight Self-Isolation', 
       y = 'Actual Response',
       col = 'Number of infections') +
  theme_light()
c <- ggplot(publicGoodsData %>% filter(!is.na(player.second_player_contribution_2)), 
       (aes(x = factor(player.second_player_contribution_2), y = player.contribution, col = group.total_infections))) +
  geom_jitter(height = .3, width = .3) +
  scale_colour_viridis_c(begin = 0, end = .85) +
  labs(x = 'Response if Second Player Contribution = Moderate Self-Isolation', 
       y = 'Actual Response',
       col = 'Number of infections') +
  theme_light()
d <- ggplot(publicGoodsData %>% filter(!is.na(player.second_player_contribution_3)), 
       (aes(x = factor(player.second_player_contribution_3), y = player.contribution, col = group.total_infections))) +
  geom_jitter(height = .3, width = .3) +
  scale_colour_viridis_c(begin = 0, end = .85) +
  labs(x = 'Response if Second Player Contribution = Stringent Self-Isolation', 
       y = 'Actual Response',
       col = 'Number of infections') +
  theme_light()
e <- ggplot(publicGoodsData %>% filter(!is.na(player.second_player_contribution_4)), 
       (aes(x = factor(player.second_player_contribution_4), y = player.contribution, col = group.total_infections))) +
  geom_jitter(height = .3, width = .3) +
  scale_colour_viridis_c(begin = 0, end = .85) +
  labs(x = 'Response if Second Player Contribution = Complete Self-Isolation', 
       y = 'Actual Response',
       col = 'Number of infections') +
  theme_light()

ggarrange(a, b, c, d, e) +
  ggsave('SecondPlayerPlots.png', width = 18, height = 8)
  


```

```{r P Game v C Game plot}
SummaryData <- publicGoodsData %>%
  filter(!is.na(actualMinusModerate)) %>%
  group_by(group.total_infections) %>%
  summarise(`None (0)` = mean(actualMinusNo),
            `Slight (1)` = mean(actualMinusSlight),
            `Moderate (2)` = mean(actualMinusModerate),
            `Stringent (3)` = mean(actualMinusStringent),
            `Complete (4)` = mean(actualMinusComplete),
            `Actual Contribution` = mean(player.contribution)) %>%
  pivot_longer(cols = 2:6, names_to = "assumedAverageContribution", values_to = "value") %>%
  mutate(assumedAverageContribution = factor(assumedAverageContribution,
                                             levels = c("None (0)",
                                                        "Slight (1)",
                                                        "Moderate (2)",
                                                        "Stringent (3)",
                                                        "Complete (4)"
                                                        )))

ggplot(SummaryData %>% 
         filter(group.total_infections < 5), 
       aes(x = assumedAverageContribution, 
                        y = group.total_infections,
                        size = `Actual Contribution`,
                        col = value)) +
  geom_point() +
  scale_colour_gradient2(low = "red", mid = 'green', high = "red") +
  labs(x = 'Assumed self-isolation of others',
       y = 'Number of infections in the group',
       size = 'Actual Average\nContribution',
       col = 'Difference Incentivised-Hypothetical') +
 # scale_size(range = c(6, 8)) + 
  scale_size_binned(range = c(4, 8)) +
  theme_light() +
  theme(axis.text.x = element_text(size = 7))


ggplot(SummaryData %>% 
         filter(group.total_infections < 5), 
       aes(x = assumedAverageContribution, 
                        y = group.total_infections,
                        col = value)) +
  geom_point(size = 7) +
  scale_colour_gradient2(low = "red", mid = 'green', high = "red") +
  labs(x = 'Assumed self-isolation of others',
       y = 'Number of infections in the group',
       col = 'Difference Incentivised-Hypothetical') +
 # scale_size(range = c(6, 8)) + 
  scale_size_binned(range = c(4, 8)) +
  theme_light() +
  theme(axis.text.x = element_text(size = 7))



```

```{r Descriptives}

View(publicGoodsData %>% filter(group.total_infections < 6) %>% group_by(group.condition, group.total_infections) %>% summarise(lockdown = mean(player.contribution, na.rm = T)))

publicGoodsData %>% 
  filter(group.total_infections < 6) %>% 
  group_by(group.total_infections) %>% 
  summarise(`Second Player Contribution - None` = mean(player.second_player_contribution_0, na.rm = T),
            `Second Player Contribution - Slight` = mean(player.second_player_contribution_1, na.rm = T),
            `Second Player Contribution - Moderate` = mean(player.second_player_contribution_2, na.rm = T),
            `Second Player Contribution - Stringent` = mean(player.second_player_contribution_3, na.rm = T),
            `Second Player Contribution - Complete` = mean(player.second_player_contribution_4, na.rm = T))



```


```{r Analysis}

lmmContribution <-
  mixed(player.contribution ~
          subsession.round_number +
          group.total_infections +
          factor(player.my_endowment) +
          (subsession.round_number|session.code/participant.code),
        data = publicGoodsData)
nice(lmmContribution)

publicGoodsData <- 
  publicGoodsData %>%
  mutate(actualMinusNo = player.contribution-player.second_player_contribution_0,
    actualMinusSlight = player.contribution-player.second_player_contribution_1,
    actualMinusModerate = player.contribution-player.second_player_contribution_2,
    actualMinusStringent = player.contribution-player.second_player_contribution_3,
    actualMinusComplete = player.contribution-player.second_player_contribution_4)

SummaryData <- publicGoodsData %>%
  filter(!is.na(actualMinusModerate)) %>%
  group_by(group.total_infections) %>%
  summarise(`No Self-Isolation` = mean(actualMinusNo),
            `Slight Self-Isolation` = mean(actualMinusSlight),
            `Moderate Self-Isolation` = mean(actualMinusModerate),
            `Stringent Self-Isolation` = mean(actualMinusStringent),
            `Complete Self-Isolation` = mean(actualMinusComplete),
            `Actual Contribution` = mean(player.contribution)) %>%
  pivot_longer(cols = 2:6, names_to = "assumedAverageContribution", values_to = "value")



```

```{r Role splitting, warning=FALSE}

rolesData <- 
  publicGoodsData %>%
  group_by(participant.code, subsession.round_number) %>%
  summarise(secondPlayer0 = mean(player.second_player_contribution_0, na.rm = T),
            secondPlayer1 = mean(player.second_player_contribution_1, na.rm = T),
            secondPlayer2 = mean(player.second_player_contribution_2, na.rm = T),
            secondPlayer3 = mean(player.second_player_contribution_3, na.rm = T),
            secondPlayer4 = mean(player.second_player_contribution_4, na.rm = T)) %>%
  pivot_longer(cols = secondPlayer0:secondPlayer4,
               names_to = "Self-isolation of others",
               values_to = "Self-isolation") %>%
  mutate(`Self-isolation of others` = rep(c(0,1,2,3,4), times = 20))


nested <- rolesData %>% 
  nest(data = -participant.code)

nested <- 
  nested %>% 
  mutate(
    test = map(data, ~ cor.test(.x$`Self-isolation of others`, .x$`Self-isolation`, method = 'spearman')), # S3 list-col
    tidied = map(test, tidy)
  )  %>%
  unnest(tidied) %>%
  filter(estimate > 0, p.value < .05)

#rolesData %>% group_by(participant.code) %>% summarise(selfIso = mean(`Self-isolation`, na.rm = T)) %>% filter(selfIso == 0)
# no participant is a strict free rider
#publicGoodsData %>% group_by(participant.code) %>% summarise(selfIso = mean(player.contribution, na.rm = T)) %>% filter(selfIso == 0)
# neither in the c-game

triangleContributorData <- 
  rolesData %>%
  group_by(participant.code, `Self-isolation of others`) %>%
  summarise(`Self-isolation` = mean(`Self-isolation`, na.rm = T)) %>%
  pivot_wider(id_cols = participant.code,
              names_from = "Self-isolation of others",
              names_prefix = "Others",
              values_from = "Self-isolation") %>%
  mutate(triangleContributor = ifelse(Others3 > Others4 & Others3 > Others2 & Others3 > Others1 & Others3 > Others0, T,
                                      ifelse(Others2 > Others0 & Others2 > Others1 & Others2 > Others3 & Others2 > Others4, T, 
                                             ifelse(Others1 > Others0 & Others1 > Others2 & Others1 > Others3 & Others1 > Others4, T, F)))) %>%
  filter(triangleContributor == T)







```

```{r power, warning=FALSE}

n <- 216
meanDifference = .45
numSims = 100
i <- 0
set.seed(1)
powerByN <- tibble(power = 0)
pValues <- tibble(pValue = 0)

for (i in 1:numSims) {
powerData <- tibble(stayHome = c(rnorm(n/2, 2.45, .9), rnorm(n/2, 2.45-meanDifference, 9)),
                    framing = factor(rep(c(1,2), each = n/2)),
                    session = factor(c(rep(seq(1:(n/9)), each = 9))))
a <- t.test(selfIsolation ~ framing, data = powerData %>% group_by(framing, session) %>% summarise(selfIsolation = mean(stayHome)))
pValues[i,1] <- as.numeric(a$p.value)
}

powerByN <- powerByN %>%
  mutate(power = pValues %>% filter(pValue < .05) %>% nrow()/numSims)

nmin <- 50
nmax <- 300
step <- 50
nVector <- seq(nmin, nmax, step) # A vector specifying how many participants per simulation set.

nsim <- 1000 # number of simulations, for your final version, the benchmark is doing 10.000 simulations

simValues <- tibble(pValue = NA, 
                     ControlMean = NA, 
                     TreatmentMean = NA)
sim.power.by.n <- tibble(n = nVector, power = NA)

# Timing the code
start_time <- Sys.time()

i=1
j=1
set.seed(1) # ALWAYS set the seed for reproducibility! R can only create pseudo random numbers, not actual random numbers. If you set the seed, you will get the same results every time, because the same pseudo random numbers will be produced.

for (j in 1:length(nVector)) {
  for (i in 1:nsim) {
    DataSimulation <- tibble(
      SubjectId = factor(adjective_animal(nVector[j], max_len = 5)),
      b0 = constant,
      b1 = effectSize,
      x = (rep(c(1,0), times = nVector[j]/2)), #Here I multiply it by n/2 because it is a between design, see what happens if you multiply by nVector.
      e = rnorm(nVector[j], 0, error), #Introducing variation in the outcome variable.
      y = b0 + b1*x + e)
    
    a <- t.test(y ~ x, data = DataSimulation) # Here it would be more elegant to use lm instead of a t-test, but I will not, for the sake of simplicity.
    simValues[i,1] <- a$p.value # Each observation in this column is a p-value
    simValues[i,2:3] <- a$estimate # Each observation in these columns is a mean.
    i=i+1
  }
  simValues$pValue <- as.numeric(ifelse(simValues$pValue == '<.0001', .0001, simValues$pValue)) # Fix an issue with the t-test output format of p-values, it's crude, but it works.
  sim.power.by.n[j,2] <- simValues %>% filter(pValue < 0.05) %>% nrow/nsim ## We filter on p<0.05, and then see what the proportion of simulations have that.
  cat("R is finished with simulation set",j, "out of", length(nVector), ".\n")
  j=j+1
}

# Timing again, to see how long the simulations took.
end_time <- Sys.time()
RunTime <- end_time - start_time
cat("It took R ", RunTime, " seconds/minutes to run these simulations." )

# Step 7 - Graph your results. Again, please create more graphs than this, for your own understanding of the data.

powerPlot <- ggplot(data=sim.power.by.n, aes(x=n, y=power)) +
              geom_line() +
              geom_point() +
              theme_minimal() +
              ylim(0.2, 1)

#This one only uses the last simulation set, this can be made to be more elaborate.
meanDensity <- simValues %>% gather(c(ControlMean, TreatmentMean), key = 'Treatment', value = 'LLProportion')
meanDenistyPlot <- ggplot(meanDensity, aes(x = LLProportion, fill = Treatment)) +
                    geom_density(alpha = 0.4)

powerPlot

meanDenistyPlot

# Now you can play with all the values, parameters and complexity to make the most accurate power analysis.




```


```
